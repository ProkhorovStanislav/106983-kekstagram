{"version":3,"sources":["webpack:///webpack/bootstrap ae1386343d0bf1c5a088","webpack:///./src/main.js","webpack:///./src/upload.js","webpack:///./src/resizer.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;;;;;;ACHA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,8BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;;;;;ACzQD;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ae1386343d0bf1c5a088\n **/","'use strict';\r\n\r\nrequire('./upload');\r\nrequire('./resizer');\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/* global Resizer: true */\r\n\r\n/**\r\n * @fileoverview\r\n * @author Igor Alexeenko (o0)\r\n */\r\n\r\n'use strict';\r\n\r\n(function() {\r\n  /** @enum {string} */\r\n  var FileType = {\r\n    'GIF': '',\r\n    'JPEG': '',\r\n    'PNG': '',\r\n    'SVG+XML': ''\r\n  };\r\n\r\n  /** @enum {number} */\r\n  var Action = {\r\n    ERROR: 0,\r\n    UPLOADING: 1,\r\n    CUSTOM: 2\r\n  };\r\n\r\n  /**\r\n   * Регулярное выражение, проверяющее тип загружаемого файла. Составляется\r\n   * из ключей FileType.\r\n   * @type {RegExp}\r\n   */\r\n  var fileRegExp = new RegExp('^image/(' + Object.keys(FileType).join('|').replace('\\+', '\\\\+') + ')$', 'i');\r\n\r\n  /**\r\n   * @type {Object.<string, string>}\r\n   */\r\n  var filterMap;\r\n\r\n  /**\r\n   * Объект, который занимается кадрированием изображения.\r\n   * @type {Resizer}\r\n   */\r\n  var currentResizer;\r\n\r\n  /**\r\n   * Удаляет текущий объект {@link Resizer}, чтобы создать новый с другим\r\n   * изображением.\r\n   */\r\n  function cleanupResizer() {\r\n    if (currentResizer) {\r\n      currentResizer.remove();\r\n      currentResizer = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ставит одну из трех случайных картинок на фон формы загрузки.\r\n   */\r\n  function updateBackground() {\r\n    var images = [\r\n      'img/logo-background-1.jpg',\r\n      'img/logo-background-2.jpg',\r\n      'img/logo-background-3.jpg'\r\n    ];\r\n\r\n    var backgroundElement = document.querySelector('.upload');\r\n    var randomImageNumber = Math.round(Math.random() * (images.length - 1));\r\n    backgroundElement.style.backgroundImage = 'url(' + images[randomImageNumber] + ')';\r\n  }\r\n\r\n  /**\r\n   * Проверяет, валидны ли данные, в форме кадрирования.\r\n   * @return {boolean}\r\n   */\r\n  function resizeFormIsValid() {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Форма загрузки изображения.\r\n   * @type {HTMLFormElement}\r\n   */\r\n  var uploadForm = document.forms['upload-select-image'];\r\n\r\n  /**\r\n   * Форма кадрирования изображения.\r\n   * @type {HTMLFormElement}\r\n   */\r\n  var resizeForm = document.forms['upload-resize'];\r\n\r\n  /**\r\n   * Форма добавления фильтра.\r\n   * @type {HTMLFormElement}\r\n   */\r\n  var filterForm = document.forms['upload-filter'];\r\n\r\n  /**\r\n   * @type {HTMLImageElement}\r\n   */\r\n  var filterImage = filterForm.querySelector('.filter-image-preview');\r\n\r\n  /**\r\n   * @type {HTMLElement}\r\n   */\r\n  var uploadMessage = document.querySelector('.upload-message');\r\n\r\n  /**\r\n   * @param {Action} action\r\n   * @param {string=} message\r\n   * @return {Element}\r\n   */\r\n  function showMessage(action, message) {\r\n    var isError = false;\r\n\r\n    switch (action) {\r\n      case Action.UPLOADING:\r\n        message = message || 'Кексограмим&hellip;';\r\n        break;\r\n\r\n      case Action.ERROR:\r\n        isError = true;\r\n        message = message || 'Неподдерживаемый формат файла<br> <a href=\"' + document.location + '\">Попробовать еще раз</a>.';\r\n        break;\r\n    }\r\n\r\n    uploadMessage.querySelector('.upload-message-container').innerHTML = message;\r\n    uploadMessage.classList.remove('invisible');\r\n    uploadMessage.classList.toggle('upload-message-error', isError);\r\n    return uploadMessage;\r\n  }\r\n\r\n  function hideMessage() {\r\n    uploadMessage.classList.add('invisible');\r\n  }\r\n\r\n  /**\r\n   * Обработчик изменения изображения в форме загрузки. Если загруженный\r\n   * файл является изображением, считывается исходник картинки, создается\r\n   * Resizer с загруженной картинкой, добавляется в форму кадрирования\r\n   * и показывается форма кадрирования.\r\n   * @param {Event} evt\r\n   */\r\n  uploadForm.onchange = function(evt) {\r\n    var element = evt.target;\r\n    if (element.id === 'upload-file') {\r\n      // Проверка типа загружаемого файла, тип должен быть изображением\r\n      // одного из форматов: JPEG, PNG, GIF или SVG.\r\n      if (fileRegExp.test(element.files[0].type)) {\r\n        var fileReader = new FileReader();\r\n\r\n        showMessage(Action.UPLOADING);\r\n\r\n        fileReader.onload = function() {\r\n          cleanupResizer();\r\n\r\n          currentResizer = new Resizer(fileReader.result);\r\n          currentResizer.setElement(resizeForm);\r\n          uploadMessage.classList.add('invisible');\r\n\r\n          uploadForm.classList.add('invisible');\r\n          resizeForm.classList.remove('invisible');\r\n\r\n          hideMessage();\r\n        };\r\n\r\n        fileReader.readAsDataURL(element.files[0]);\r\n      } else {\r\n        // Показ сообщения об ошибке, если формат загружаемого файла не поддерживается\r\n        showMessage(Action.ERROR);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Обработка сброса формы кадрирования. Возвращает в начальное состояние\r\n   * и обновляет фон.\r\n   * @param {Event} evt\r\n   */\r\n  resizeForm.onreset = function(evt) {\r\n    evt.preventDefault();\r\n\r\n    cleanupResizer();\r\n    updateBackground();\r\n\r\n    resizeForm.classList.add('invisible');\r\n    uploadForm.classList.remove('invisible');\r\n  };\r\n\r\n  /**\r\n   * Обработка отправки формы кадрирования. Если форма валидна, экспортирует\r\n   * кропнутое изображение в форму добавления фильтра и показывает ее.\r\n   * @param {Event} evt\r\n   */\r\n  resizeForm.onsubmit = function(evt) {\r\n    evt.preventDefault();\r\n\r\n    if (resizeFormIsValid()) {\r\n      var image = currentResizer.exportImage().src;\r\n\r\n      var thumbnails = filterForm.querySelectorAll('.upload-filter-preview');\r\n      for (var i = 0; i < thumbnails.length; i++) {\r\n        thumbnails[i].style.backgroundImage = 'url(' + image + ')';\r\n      }\r\n\r\n      filterImage.src = image;\r\n\r\n      resizeForm.classList.add('invisible');\r\n      filterForm.classList.remove('invisible');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Сброс формы фильтра. Показывает форму кадрирования.\r\n   * @param {Event} evt\r\n   */\r\n  filterForm.onreset = function(evt) {\r\n    evt.preventDefault();\r\n\r\n    filterForm.classList.add('invisible');\r\n    resizeForm.classList.remove('invisible');\r\n  };\r\n\r\n  /**\r\n   * Отправка формы фильтра. Возвращает в начальное состояние, предварительно\r\n   * записав сохраненный фильтр в cookie.\r\n   * @param {Event} evt\r\n   */\r\n  filterForm.onsubmit = function(evt) {\r\n    evt.preventDefault();\r\n\r\n    cleanupResizer();\r\n    updateBackground();\r\n\r\n    filterForm.classList.add('invisible');\r\n    uploadForm.classList.remove('invisible');\r\n  };\r\n\r\n  /**\r\n   * Обработчик изменения фильтра. Добавляет класс из filterMap соответствующий\r\n   * выбранному значению в форме.\r\n   */\r\n  filterForm.onchange = function() {\r\n    if (!filterMap) {\r\n      // Ленивая инициализация. Объект не создается до тех пор, пока\r\n      // не понадобится прочитать его в первый раз, а после этого запоминается\r\n      // навсегда.\r\n      filterMap = {\r\n        'none': 'filter-none',\r\n        'chrome': 'filter-chrome',\r\n        'sepia': 'filter-sepia',\r\n        'marvin': 'filter-marvin'\r\n      };\r\n    }\r\n\r\n    var selectedFilter = [].filter.call(filterForm['upload-filter'], function(item) {\r\n      return item.checked;\r\n    })[0].value;\r\n\r\n    // Класс перезаписывается, а не обновляется через classList потому что нужно\r\n    // убрать предыдущий примененный класс. Для этого нужно или запоминать его\r\n    // состояние или просто перезаписывать.\r\n    filterImage.className = 'filter-image-preview ' + filterMap[selectedFilter];\r\n  };\r\n\r\n  cleanupResizer();\r\n  updateBackground();\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/upload.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\r\n\r\n(function() {\r\n  /**\r\n   * @constructor\r\n   * @param {string} image\r\n   */\r\n  var Resizer = function(image) {\r\n    // Изображение, с которым будет вестись работа.\r\n    this._image = new Image();\r\n    this._image.src = image;\r\n\r\n    // Холст.\r\n    this._container = document.createElement('canvas');\r\n    this._ctx = this._container.getContext('2d');\r\n\r\n    // Создаем холст только после загрузки изображения.\r\n    this._image.onload = function() {\r\n      // Размер холста равен размеру загруженного изображения. Это нужно\r\n      // для удобства работы с координатами.\r\n      this._container.width = this._image.naturalWidth;\r\n      this._container.height = this._image.naturalHeight;\r\n\r\n      /**\r\n       * Предлагаемый размер кадра в виде коэффициента относительно меньшей\r\n       * стороны изображения.\r\n       * @const\r\n       * @type {number}\r\n       */\r\n      var INITIAL_SIDE_RATIO = 0.75;\r\n\r\n      // Размер меньшей стороны изображения.\r\n      var side = Math.min(\r\n          this._container.width * INITIAL_SIDE_RATIO,\r\n          this._container.height * INITIAL_SIDE_RATIO);\r\n\r\n      // Изначально предлагаемое кадрирование — часть по центру с размером в 3/4\r\n      // от размера меньшей стороны.\r\n      this._resizeConstraint = new Square(\r\n          this._container.width / 2 - side / 2,\r\n          this._container.height / 2 - side / 2,\r\n          side);\r\n\r\n      // Отрисовка изначального состояния канваса.\r\n      this.setConstraint();\r\n    }.bind(this);\r\n\r\n    // Фиксирование контекста обработчиков.\r\n    this._onDragStart = this._onDragStart.bind(this);\r\n    this._onDragEnd = this._onDragEnd.bind(this);\r\n    this._onDrag = this._onDrag.bind(this);\r\n  };\r\n\r\n  Resizer.prototype = {\r\n    /**\r\n     * Родительский элемент канваса.\r\n     * @type {Element}\r\n     * @private\r\n     */\r\n    _element: null,\r\n\r\n    /**\r\n     * Положение курсора в момент перетаскивания. От положения курсора\r\n     * рассчитывается смещение на которое нужно переместить изображение\r\n     * за каждую итерацию перетаскивания.\r\n     * @type {Coordinate}\r\n     * @private\r\n     */\r\n    _cursorPosition: null,\r\n\r\n    /**\r\n     * Объект, хранящий итоговое кадрирование: сторона квадрата и смещение\r\n     * от верхнего левого угла исходного изображения.\r\n     * @type {Square}\r\n     * @private\r\n     */\r\n    _resizeConstraint: null,\r\n\r\n    /**\r\n     * Отрисовка канваса.\r\n     */\r\n    redraw: function() {\r\n      // Очистка изображения.\r\n      this._ctx.clearRect(0, 0, this._container.width, this._container.height);\r\n\r\n      // Параметры линии.\r\n      // NB! Такие параметры сохраняются на время всего процесса отрисовки\r\n      // canvas'a поэтому важно вовремя поменять их, если нужно начать отрисовку\r\n      // чего-либо с другой обводкой.\r\n\r\n      // Толщина линии.\r\n      this._ctx.lineWidth = 6;\r\n      // Цвет обводки.\r\n      this._ctx.strokeStyle = '#ffe753';\r\n      // Размер штрихов. Первый элемент массива задает длину штриха, второй\r\n      // расстояние между соседними штрихами.\r\n      this._ctx.setLineDash([15, 10]);\r\n      // Смещение первого штриха от начала линии.\r\n      this._ctx.lineDashOffset = 7;\r\n\r\n      // Сохранение состояния канваса.\r\n      this._ctx.save();\r\n\r\n      // Установка начальной точки системы координат в центр холста.\r\n      this._ctx.translate(this._container.width / 2, this._container.height / 2);\r\n\r\n      var displX = -(this._resizeConstraint.x + this._resizeConstraint.side / 2);\r\n      var displY = -(this._resizeConstraint.y + this._resizeConstraint.side / 2);\r\n\r\n      // Отрисовка изображения на холсте. Параметры задают изображение, которое\r\n      // нужно отрисовать и координаты его верхнего левого угла.\r\n      // Координаты задаются от центра холста.\r\n      this._ctx.drawImage(this._image, displX, displY);\r\n\r\n      // Отрисовка прямоугольника, обозначающего область изображения после\r\n      // кадрирования. Координаты задаются от центра.\r\n      /*this._ctx.strokeRect(\r\n          (-this._resizeConstraint.side / 2),\r\n          (-this._resizeConstraint.side / 2 - this._ctx.lineWidth / 2),\r\n          this._resizeConstraint.side - this._ctx.lineWidth / 2,\r\n          this._resizeConstraint.side - this._ctx.lineWidth / 2);*/\r\n\r\n      // Добавляем затенение области, выходящей за рамку изображения после кадрирования\r\n      this._ctx.beginPath();\r\n      // Отрисовка внутренней границы области, совпадающей с рамкой изображения после кадрирования\r\n      this._ctx.moveTo((-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2, (-this._resizeConstraint.side / 2) - this._ctx.lineWidth);\r\n      this._ctx.lineTo((this._resizeConstraint.side / 2), (-this._resizeConstraint.side / 2) - this._ctx.lineWidth);\r\n      this._ctx.lineTo((this._resizeConstraint.side / 2), (this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2);\r\n      this._ctx.lineTo((-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2, (this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2);\r\n      this._ctx.lineTo((-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2, (-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2);\r\n\r\n      // Отрисовка внешней границы области, совпадающей с размерами загружаемого изображения\r\n      this._ctx.moveTo(-this._container.width / 2, -this._container.height / 2);\r\n      this._ctx.lineTo(this._container.width / 2, -this._container.height / 2);\r\n      this._ctx.lineTo(this._container.width / 2, this._container.height / 2);\r\n      this._ctx.lineTo(-this._container.width / 2, this._container.height / 2);\r\n      this._ctx.lineTo(-this._container.width / 2, -this._container.height / 2);\r\n\r\n      // Задание параметров затеняющего слоя\r\n      this._ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n      this._ctx.fill('evenodd');\r\n\r\n      // Добавляем параметры текстового описания размеров загружаемого изображения\r\n      this._ctx.textAlign = 'center';\r\n      this._ctx.font = '20px Arial';\r\n      this._ctx.fillStyle = '#fff';\r\n      this._ctx.fillText( this._image.naturalWidth + ' x ' + this._image.naturalHeight, 0, -this._container.height * 0.75 / 2 - 9);\r\n\r\n      document.body.appendChild(this.getMyCanvas());\r\n\r\n      // Восстановление состояния канваса, которое было до вызова ctx.save\r\n      // и последующего изменения системы координат. Нужно для того, чтобы\r\n      // следующий кадр рисовался с привычной системой координат, где точка\r\n      // 0 0 находится в левом верхнем углу холста, в противном случае\r\n      // некорректно сработает даже очистка холста или нужно будет использовать\r\n      // сложные рассчеты для координат прямоугольника, который нужно очистить.\r\n      this._ctx.restore();\r\n    },\r\n\r\n    // Отрисовывание рамки из точек. Для отрисовки каждой стороны вызывается функция с соответствующими параметрами\r\n    getMyCanvas: function() {\r\n      var borderElem = document.createElement('canvas');\r\n      var dotSize = 2;\r\n\r\n      this.drawBorder(\r\n          -this._resizeConstraint.side / 2 - dotSize,\r\n          -this._resizeConstraint.side / 2 - dotSize * 3,\r\n          this._resizeConstraint.side / 2,\r\n          -this._resizeConstraint.side / 2 - dotSize * 3,\r\n          dotSize);\r\n\r\n      this.drawBorder(\r\n          -this._resizeConstraint.side / 2 - dotSize,\r\n          -this._resizeConstraint.side / 2 - dotSize * 2,\r\n          -this._resizeConstraint.side / 2 - dotSize,\r\n          this._resizeConstraint.side / 2,\r\n          dotSize);\r\n\r\n      this.drawBorder(\r\n          this._resizeConstraint.side / 2,\r\n          -this._resizeConstraint.side / 2 - dotSize * 2,\r\n          this._resizeConstraint.side / 2,\r\n          this._resizeConstraint.side / 2,\r\n          dotSize);\r\n\r\n      this.drawBorder(\r\n          -this._resizeConstraint.side / 2,\r\n          this._resizeConstraint.side / 2 - dotSize * 2,\r\n          this._resizeConstraint.side / 2,\r\n          this._resizeConstraint.side / 2 - dotSize * 2,\r\n          dotSize);\r\n\r\n      return borderElem;\r\n    },\r\n\r\n    /**\r\n     * Отрисовывание единичного кружка - элемента кастомной рамки, обозначающей область изображения после кадрирования. Координаты задаются от центра.\r\n     */\r\n    drawDot: function(ctx, size, x, y) {\r\n      this._ctx.beginPath();\r\n      this._ctx.arc(x, y, size, 0, Math.PI * 2, false);\r\n      this._ctx.fillStyle = '#ffe753';\r\n      this._ctx.fill();\r\n    },\r\n\r\n    /**\r\n     * Функция отрисовки рамки получает 4 параметра\r\n     * @param x - начальная координата линии по оси X\r\n     * @param y - начальная координата линии по оси Y\r\n     * @param m - конечная координата линии по оси X\r\n     * @param n - конечная координата линии по оси Y\r\n     * @param dotSize - радиус точки, элемента рамки\r\n     * Сравнивая переданные параметры попарно, функция рисует либо горизонтальную либо вертикальную сторону рамки\r\n     */\r\n    drawBorder: function(x, y, m, n, dotSize) {\r\n      if (x !== m && y !== n || x === m && y === n || x > m || y > n) {\r\n        console.log('the parameters passed to the function are incorrect');\r\n        return;\r\n      }\r\n\r\n      if (y === n) {\r\n        while (x < m) {\r\n          this.drawDot(this._ctx, dotSize, x, y);\r\n          x += dotSize * 3;\r\n        }\r\n      }\r\n\r\n      if (x === m) {\r\n        while (y < n) {\r\n          this.drawDot(this._ctx, dotSize, x, y);\r\n          y += dotSize * 3;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Включение режима перемещения. Запоминается текущее положение курсора,\r\n     * устанавливается флаг, разрешающий перемещение и добавляются обработчики,\r\n     * позволяющие перерисовывать изображение по мере перетаскивания.\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @private\r\n     */\r\n    _enterDragMode: function(x, y) {\r\n      this._cursorPosition = new Coordinate(x, y);\r\n      document.body.addEventListener('mousemove', this._onDrag);\r\n      document.body.addEventListener('mouseup', this._onDragEnd);\r\n    },\r\n\r\n    /**\r\n     * Выключение режима перемещения.\r\n     * @private\r\n     */\r\n    _exitDragMode: function() {\r\n      this._cursorPosition = null;\r\n      document.body.removeEventListener('mousemove', this._onDrag);\r\n      document.body.removeEventListener('mouseup', this._onDragEnd);\r\n    },\r\n\r\n    /**\r\n     * Перемещение изображения относительно кадра.\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @private\r\n     */\r\n    updatePosition: function(x, y) {\r\n      this.moveConstraint(\r\n          this._cursorPosition.x - x,\r\n          this._cursorPosition.y - y);\r\n      this._cursorPosition = new Coordinate(x, y);\r\n    },\r\n\r\n    /**\r\n     * @param {MouseEvent} evt\r\n     * @private\r\n     */\r\n    _onDragStart: function(evt) {\r\n      this._enterDragMode(evt.clientX, evt.clientY);\r\n    },\r\n\r\n    /**\r\n     * Обработчик окончания перетаскивания.\r\n     * @private\r\n     */\r\n    _onDragEnd: function() {\r\n      this._exitDragMode();\r\n    },\r\n\r\n    /**\r\n     * Обработчик события перетаскивания.\r\n     * @param {MouseEvent} evt\r\n     * @private\r\n     */\r\n    _onDrag: function(evt) {\r\n      this.updatePosition(evt.clientX, evt.clientY);\r\n    },\r\n\r\n    /**\r\n     * Добавление элемента в DOM.\r\n     * @param {Element} element\r\n     */\r\n    setElement: function(element) {\r\n      if (this._element === element) {\r\n        return;\r\n      }\r\n\r\n      this._element = element;\r\n      this._element.insertBefore(this._container, this._element.firstChild);\r\n      // Обработчики начала и конца перетаскивания.\r\n      this._container.addEventListener('mousedown', this._onDragStart);\r\n    },\r\n\r\n    /**\r\n     * Возвращает кадрирование элемента.\r\n     * @return {Square}\r\n     */\r\n    getConstraint: function() {\r\n      return this._resizeConstraint;\r\n    },\r\n\r\n    /**\r\n     * Смещает кадрирование на значение указанное в параметрах.\r\n     * @param {number} deltaX\r\n     * @param {number} deltaY\r\n     * @param {number} deltaSide\r\n     */\r\n    moveConstraint: function(deltaX, deltaY, deltaSide) {\r\n      this.setConstraint(\r\n          this._resizeConstraint.x + (deltaX || 0),\r\n          this._resizeConstraint.y + (deltaY || 0),\r\n          this._resizeConstraint.side + (deltaSide || 0));\r\n    },\r\n\r\n    /**\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} side\r\n     */\r\n    setConstraint: function(x, y, side) {\r\n      if (typeof x !== 'undefined') {\r\n        this._resizeConstraint.x = x;\r\n      }\r\n\r\n      if (typeof y !== 'undefined') {\r\n        this._resizeConstraint.y = y;\r\n      }\r\n\r\n      if (typeof side !== 'undefined') {\r\n        this._resizeConstraint.side = side;\r\n      }\r\n\r\n      requestAnimationFrame(function() {\r\n        this.redraw();\r\n        window.dispatchEvent(new CustomEvent('resizerchange'));\r\n      }.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Удаление. Убирает контейнер из родительского элемента, убирает\r\n     * все обработчики событий и убирает ссылки.\r\n     */\r\n    remove: function() {\r\n      this._element.removeChild(this._container);\r\n\r\n      this._container.removeEventListener('mousedown', this._onDragStart);\r\n      this._container = null;\r\n    },\r\n\r\n    /**\r\n     * Экспорт обрезанного изображения как HTMLImageElement и исходником\r\n     * картинки в src в формате dataURL.\r\n     * @return {Image}\r\n     */\r\n    exportImage: function() {\r\n      // Создаем Image, с размерами, указанными при кадрировании.\r\n      var imageToExport = new Image();\r\n\r\n      // Создается новый canvas, по размерам совпадающий с кадрированным\r\n      // изображением, в него добавляется изображение взятое из канваса\r\n      // с измененными координатами и сохраняется в dataURL, с помощью метода\r\n      // toDataURL. Полученный исходный код, записывается в src у ранее\r\n      // созданного изображения.\r\n      var temporaryCanvas = document.createElement('canvas');\r\n      var temporaryCtx = temporaryCanvas.getContext('2d');\r\n      temporaryCanvas.width = this._resizeConstraint.side;\r\n      temporaryCanvas.height = this._resizeConstraint.side;\r\n      temporaryCtx.drawImage(this._image,\r\n          -this._resizeConstraint.x,\r\n          -this._resizeConstraint.y);\r\n      imageToExport.src = temporaryCanvas.toDataURL('image/png');\r\n\r\n      return imageToExport;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Вспомогательный тип, описывающий квадрат.\r\n   * @constructor\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} side\r\n   * @private\r\n   */\r\n  var Square = function(x, y, side) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.side = side;\r\n  };\r\n\r\n  /**\r\n   * Вспомогательный тип, описывающий координату.\r\n   * @constructor\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @private\r\n   */\r\n  var Coordinate = function(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  };\r\n\r\n  window.Resizer = Resizer;\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/resizer.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}